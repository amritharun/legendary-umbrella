# legendary-umbrella
Simple web app that visualizes synthetic n port data.

For anyone curious, the name of the project was auto-generated by github.

Hosted [here](https://legendary-umbrella-og15.onrender.com/)

## Install Instructions
**_NOTE:_** [Docker](https://www.docker.com) is a prerequisite to run this web app locally.

From the root of the repository run the following command:

```console
docker compose up --build
```

Navigate to `localhost:5000` in your browser and the webpage should render.

## Test Instructions
To run the test suite for this project run the following command from the root of the repository:
```console
python3 -m unittest discover .
```

## Design Choices
This python application was built using [flask](https://flask.palletsprojects.com/en/stable/) + [htmx](https://htmx.org/). I find flask to be a great framework for quickly prototyping web applications, and it's easy to spin up. Htmx is a great front end library to add interactivity to the UI while writing minimal Javascript. Htmx renders from the backend making it a great choice for small teams without dedicated front-end experience. I used [gevent](https://www.gevent.org/api/gevent.pywsgi.html) as my WSGI server to serve requests in my production environment and used the [render](https://render.com/) free-tier to host the container.

I chose to use [sqlite](https://www.sqlite.org/) as my database since in this toy application never pushes updates to the state of the application, only reading various pieces of data. Sqlite allows us to abstract out the database implementation from our business logic, so in the future if we ever needed to use a different database, we'd be able to switch over with minimal issue since sqlite uses a pretty vanilla flavor of SQL. Sqlite is also great for testing since you can easily create a test db file and set up various states to test your application.

In the assignment description we were given some idea of what the data would look like so I took the liberty of making a synthetic data loader script that populates my sqlite file with some mock data (see [here](db/db_loader.py) for details). We use randomness to determine how many records there are per company and then normally distribute the holdings and value for each record.

## Functionality
Our web app consists of 2 pages, latest and historical. Both webpages share lots of code and mainly differ in which database table they use and how they visualize the data. By having both pages inherit from a common base, we're able to easily make changes that reflect in both screens and we hold true to DRY.

Users interact with the webpage by using the search bar. In there, you can type a search query for either a CIK or a company name. Once the user inputs a search query, the table loads with a view of the search results provided. The results are paginated so that the user doesn't have to scroll down super far to see the visualizations in the page. If there is more than one value present for a cik, we show the value as green/red depending on whether the value is less than or greater than the original (oldest) value. The user is also presented with a d3 bar chart visualizing the data in the table. In the historical page we show each company's resulting data in individual bar charts, while in the latest page we show all the company results in a single bar chart. If the user's query does not provide any search results, we present them with an error message and the query used.

In the database, I created a view of the `n_port_historical` table called `n_port_latest` that keeps the latest record for each CIK. Using a db that supports materialized views can have performance benefits, though it should be noted that sqlite does not have support so there's no performance benefit from this. A view does allow us to write simpler queries thus making the app more maintainable. Some other improvements I made include adding an in-memory cache with a timeout and adding rate limiting for added security. I also do some input sanitization of the search query by only keeping valid chars and removing any invalid chars and truncating the string if it's longer than any reasonable query should be.

A small addition was the usage of [locale](https://docs.python.org/3/library/locale.html) to interpret the value as a US currency. This can be easily changed in docker configuration (it's an env variable) to use any region's currency system for the future.

## Todo
- Table enhancements- Add filtering and sorting options for the various columns
- Authentication - There's currently no security for who can access and see this data so some basic authentication would be recommended as a future step

## Acknowledgements
I used several resources for help in putting together this web application
- [Claude](https://claude.ai/) - For d3 integration and some help with testing
- [Copilot](https://code.visualstudio.com/docs/copilot/overview) - For code suggestions
- I use [this](https://github.com/voidranjer/htmx-flask-crudapp) sample posts application source code as my starting point for building this project
- Various documentation sites for libraries used
